name: CI Pipeline

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: self-hosted  # self-hosted runner 사용
    steps:
      - uses: actions/checkout@v4

      # Gradle 캐시 설정
      - name: Set up Gradle cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: gradle-${{ runner.os }}-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            gradle-${{ runner.os }}-

      # Generate properties from secrets
      - name: Generate properties from secrets
        shell: bash
        run: |
          echo "jwt.secretKey=$JWT_SECRETKEY" > src/main/resources/configs/auth/jwt.properties
          echo "spring.datasource.url=$SPRING_DATASOURCE_URL" > src/main/resources/configs/database/mariadb.properties
          echo "spring.datasource.username=$SPRING_DATASOURCE_USERNAME" >> src/main/resources/configs/database/mariadb.properties
          echo "spring.datasource.password=$SPRING_DATASOURCE_PASSWORD" >> src/main/resources/configs/database/mariadb.properties
        env:
          JWT_SECRETKEY: ${{ secrets.JWT_SECRET }}
          SPRING_DATASOURCE_URL: ${{ secrets.DB_URL }}
          SPRING_DATASOURCE_USERNAME: ${{ secrets.DB_USERNAME }}
          SPRING_DATASOURCE_PASSWORD: ${{ secrets.DB_PASSWORD }}

      # 빌드 및 테스트
      - name: Build with Gradle and Test
        run: |
          chmod +x gradlew
          ./gradlew clean bootJar --info

      # jar 파일 이름 고정
      - name: Rename artifact to fixed name
        shell: bash
        run: |
          JAR_PATH=$(ls build/libs/*.jar | head -n 1)
          cp "$JAR_PATH" solicare.jar
          echo "Packaged: $(ls -l solicare.jar)"

      # 8081 포트에서 임시로 실행 테스트
      - name: Test run on port 8081
        shell: bash
        run: |
          nohup java -jar -Dserver.port=8081 solicare.jar > test_app.log 2>&1 &
          sleep 10
          if curl -sSf http://localhost:8081/actuator/health > /dev/null; then
            echo "[SUCCESS] App started successfully on 8081."
            kill $(lsof -ti:8081)
            rm -f test_app.log
          else
            echo "[ERROR] App failed to start on 8081."
            cat test_app.log
            rm -f test_app.log
            exit 1
          fi

      # 기존 프로세스 종료 및 jar 실행
      - name: Stop previous application and Run builded runtime
        shell: bash
        run: |
          ssh localhost "
            cd /home/ubuntu/actions-runner/_work/solicare-app-backend/solicare-app-backend &&
            PID=\$(lsof -ti:8080 || true)
            if [ -n \"$PID\" ]; then
              echo 'Stopping previous application (PID: '$PID')'
              kill $PID
              sleep 5
            fi
            nohup java -jar solicare.jar > app.log 2>&1 &
          "

      # 8080 포트에서 정상 동작 확인
      - name: Check if app is running on 8080
        shell: bash
        run: |
          for i in {1..3}; do
            if curl -sSf http://localhost:8080/actuator/health > /dev/null; then
              echo "App is running on 8080!"
              exit 0
            fi
            echo "Waiting for app to be ready... ($i)"
            sleep 3
          done
          echo "ERROR: App is not running on 8080 or /actuator/health is not available." >&2
          cat /home/ubuntu/actions-runner/_work/solicare-app-backend/solicare-app-backend/app.log || true
          exit 1
